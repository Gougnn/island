#version 330

#include <variables>
#include <blendmodes>
#include "/libraries/mathnoise.shadron"

#define ROTATION false
#define UP       vec3(0.0f, 0.0f, 1.0f)
#define DOWN     vec3(0.0f, 0.0f, -1.0f)

#define SEA      vec3(0.20f, 0.60f, 1.00f)
#define LAND     vec3(0.50f ,0.25f, 0.00f)

const mat2 ROTATION2D = mat2(0.8, -0.6,
                             0.6,  0.8);

const mat3 ROTATION3D = mat3(0.85, -0.64, 0.0,
                             0.64,  0.85, 0.0,
                             0.0,  0.0, 1.0);

parameter float noiseSeed        = 1.0f  : range(-10.0f, 10.0f);
parameter float noiseRandomness  = 0.0f  : range(0.0f, 1.0f);
parameter float noiseBlend       = 0.0f  : range(0.0f, 1.0f);
parameter int   noiseOctaves     = 7     : range(1, 10);
parameter float noisePersistence = 0.35f : range(0.0f, 1.0f);
parameter float noiseFrequency   = 2.1f  : range(0.0f, 5.0f);
parameter float waterLevel       = 0.4f;
parameter float lightSteps       = 50.0f : range(10.0f, 200.0f, 1.0f); 

parameter vec2  viewOffset       = vec2(0.0f) : range(vec2(-25.0f), vec2(25.0f));
parameter float viewRotation     = 0.0f       : range(-PI, PI);
parameter float viewScale        = 6.0f       : range(0.01f, 20.0f);


var vec2 MOUSE_POSITION;

//.     . CAPTURE MOUSE POSITION .     .


void getMouse(vec2 _mouse){
    MOUSE_POSITION = _mouse;
}

event mouse_position() = getMouse;
watch MOUSE_POSITION;



//.     . UTILITARIES .     .

float remap( float _value, float _fromMin, float _fromMax, float _toMin, float _toMax )
{
	return _toMin + (_value - _fromMin) * (_toMax - _toMin) / (_fromMax - _fromMin);
}

vec3 remap( vec3 _value, float _fromMin, float _fromMax, float _toMin, float _toMax )
{
    return vec3(remap(_value.x, _fromMin, _fromMax, _toMin, _toMax),
                remap(_value.y, _fromMin, _fromMax, _toMin, _toMax),
                remap(_value.z, _fromMin, _fromMax, _toMin, _toMax));
}

float smoothmin( float _a, float _b, float _k )
{
    float h = clamp(0.5 + 0.5*(_a-_b)/_k, 0.0, 1.0);
    return mix(_a, _b, h) - _k*h*(1.0-h);
}

vec2 smoothmin( vec2 _a, vec2 _b, float _k )
{
    return vec2(smoothmin(_a.x, _b.x, _k),
                smoothmin(_a.y, _b.y, _k));
}

vec3 smoothmin( vec3 _a, vec3 _b, float _k )
{
    return vec3(smoothmin(_a.x, _b.x, _k),
                smoothmin(_a.y, _b.y, _k),
                smoothmin(_a.z, _b.z, _k));
}

float blend( float a, float b, float fac )
{
    return a + fac * (2.0f * (b - 1.0f));
}

float getFalloff( vec2 _uv, float _strength )
{
    return 1.0f - pow(length(_uv), _strength);
}

        //|  DRAW FUNCTIONS

vec3 drawCenter(vec2 _uv, float _size, vec3 _dotCol, vec3 _col)
{
    return (length(_uv*10.0f - 5.0f)>_size) ? _col : _dotCol;
}


        //|  TRANSFORM UV 

vec2 transformPoint( vec2 _p, float _s, float _r, vec2 _t )
{
    mat3 
        rot =   mat3(cos(_r), -sin(_r), 0.0f,
                     sin(_r),  cos(_r), 0.0f,
                     0.0    ,  0.0    , 1.0),
        trans = mat3(1.0, 0.0, -(_t.x),
                     0.0, 1.0, -(_t.y),
                     0.0, 0.0, 1.0   );

    
    return (vec3(_p*_s, 1.0f) * rot * trans).xy;
}


        //|  NOiSE GENERATION 

float voronoise( vec2 _uv )
{
	float k = 1.0f+63.0f*pow(1.0f-noiseBlend,6.0f);

    vec3 
        i = floor(vec3(_uv, noiseSeed)),
        f = fract(vec3(_uv, noiseSeed));
    
	vec2 a = vec2(0.0,0.0);

    for( int z=-2; z<=2; z++ ){
        for( int y=-2; y<=2; y++ ){
            for( int x=-2; x<=2; x++ ){
                vec3  g = vec3( x, y , z );
	        	vec4  o = hash43( i + g )*vec4(noiseRandomness,noiseRandomness,1.0, 1.0);
	        	vec3  d = g - f + o.xyz;
	        	float w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );
	        	a += vec2(o.w*w,w);
            }
        }
    }
    return a.x/a.y;
}

float fbm( vec2 _uv )
{
    vec3 p0 = vec3(_uv, noiseSeed);
    float 
        a = 0.5f,
        f = 1.0f,
        aSum = 0.0f,
        res = 0.0f;
    
    for ( int i=0; i<noiseOctaves; i++ ){
        float n = voronoise(p0.xy);
        n = n*n*(3.0-2.0*n);
        res += n * a;
        
        aSum += a;
        a *= noisePersistence;
        f *= 2.0;
        if (ROTATION) p0 *= ROTATION3D;
        p0 *= noiseFrequency;
    }
    return remap(max(res/aSum, waterLevel), 0.0f, 1.0f, 0.0f, 1.0f);
}

//         .     . GLSL .     .      

vec3 shadow( vec2 uv )
{
    uv = vec2(uv.x, uv.y);
    vec2 uvTrans = transformPoint(uv - 0.5, viewScale, viewRotation, viewOffset); // UV TRANSFORM

    float baseHeight = fbm(uvTrans);
    vec2 mousePosition = (MOUSE_POSITION * 2.0f - 1.0f)*10.0f;
    vec3 lightDir = normalize(vec3(100.0f, 100.0f, 20.0f));

    vec3 p0 = vec3(uvTrans, baseHeight);
    vec3 p = p0;

    float n = 0.0f;
    for ( int i = 0; i <= lightSteps; i ++ )
    {
        n += 1;
        float h = fbm(p.xy);
        if (p.z > 1.1f) break;
        if (h > p.z) break;

        p+= lightDir * (1/lightSteps);//max(0.01, (p.z-h) * 0.01f);
    }

    float shadowMask = clamp(length(p - p0), 0.0f, 1.0f);
    float seaMask = (baseHeight > waterLevel + 0.00001) ? 0.0f : 1.0f;

    return vec3(shadowMask);
    // return vec3(shadowMask*clamp(hash11(baseHeight*0.5) + seaMask, 0.0f, 1.0f));
}

image SHADOW = glsl(shadow, ivec2(1024));





