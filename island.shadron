#version 330

#include <variables>
#include <blendmodes>
#include "/libraries/mathnoise.shadron"

#define UP       vec3(0.0f, 0.0f, 1.0f)
#define DOWN     vec3(0.0f, 0.0f, -1.0f)

#define SEA      vec3(0.78f, 0.88f, 1.00f)
#define LAND     vec3(0.50f ,0.25f, 0.00f)
#define DIM      vec2(1920, 1080)

parameter float noiseSeed        = 1.0f  : range(-10.0f, 10.0f);
parameter float noiseRandomness  = 0.0f  : range(0.0f, 1.0f);
parameter float noiseBlend       = 0.0f  : range(0.0f, 1.0f);
parameter int   noiseOctaves     = 7     : range(1, 10);
parameter float noisePersistence = 0.35f : range(0.0f, 1.0f);
parameter float noiseFrequency   = 2.1f  : range(0.0f, 5.0f);
parameter float noiseRotation    = 0.0f  : range(-PI, PI);
parameter float waterLevel       = 0.4f;
parameter float lightSteps       = 50.0f : range(10.0f, 200.0f, 1.0f);
parameter float lightAltitude    = 0.1f  : range(0.0f, 2.0f);
parameter float lightLongitude   = 1.0f  : range(0.0f, 1.0f);
parameter float lightRotation    = 0.0f  : range(0.0f, 7.0f, 1.0f);

parameter float viewRotation     = 0.0f       : range(-PI, PI);


var vec2 DRAG;

//.     . CAPTURE MOUSE POSITION .     .

void getDrag(vec2 _mouse){
    DRAG += _mouse*clamp(-MOUSE.z, 1.0f, 200.0f);
}
watch MOUSE.z;

event mouse_delta(left_button) = getDrag;


//.     . UTILITARIES .     .

float remap( float _value, float _fromMin, float _fromMax, float _toMin, float _toMax )
{
	return _toMin + (_value - _fromMin) * (_toMax - _toMin) / (_fromMax - _fromMin);
}

vec3 remap( vec3 _value, float _fromMin, float _fromMax, float _toMin, float _toMax )
{
    return vec3(remap(_value.x, _fromMin, _fromMax, _toMin, _toMax),
                remap(_value.y, _fromMin, _fromMax, _toMin, _toMax),
                remap(_value.z, _fromMin, _fromMax, _toMin, _toMax));
}

float smoothmin( float _a, float _b, float _k )
{
    float h = clamp(0.5 + 0.5*(_a-_b)/_k, 0.0, 1.0);
    return mix(_a, _b, h) - _k*h*(1.0-h);
}

vec2 smoothmin( vec2 _a, vec2 _b, float _k )
{
    return vec2(smoothmin(_a.x, _b.x, _k),
                smoothmin(_a.y, _b.y, _k));
}

vec3 smoothmin( vec3 _a, vec3 _b, float _k )
{
    return vec3(smoothmin(_a.x, _b.x, _k),
                smoothmin(_a.y, _b.y, _k),
                smoothmin(_a.z, _b.z, _k));
}

float blend( float a, float b, float fac )
{
    return a + fac * (2.0f * (b - 1.0f));
}

float getFalloff( vec2 _uv, float _strength )
{
    return 1.0f - pow(length(_uv), _strength);
}

        //|  DRAW FUNCTIONS

vec3 drawCenter(vec2 _uv, float _size, vec3 _dotCol, vec3 _col)
{
    return (length(_uv*10.0f - 5.0f)>_size) ? _col : _dotCol;
}


        //|  TRANSFORM UV 

vec2 transformPoint( vec2 _p, float _s, float _r, vec2 _t )
{
    mat3 
        rot =   mat3(cos(_r), -sin(_r), 0.0f,
                     sin(_r),  cos(_r), 0.0f,
                     0.0    ,  0.0    , 1.0),
        trans = mat3(1.0, 0.0, -(_t.x),
                     0.0, 1.0, -(_t.y),
                     0.0, 0.0, 1.0   );

    
    return (vec3(_p*_s, 1.0f) * rot * trans).xy;
}


        //|  NOiSE GENERATION 

float voronoise( vec2 _uv )
{
	float k = 1.0f+63.0f*pow(1.0f-noiseBlend,6.0f);

    vec3 
        i = floor(vec3(_uv, noiseSeed)),
        f = fract(vec3(_uv, noiseSeed));
    
	vec2 a = vec2(0.0,0.0);

    for( int z=-2; z<=2; z++ ){
        for( int y=-2; y<=2; y++ ){
            for( int x=-2; x<=2; x++ ){
                vec3  g = vec3( x, y , z );
	        	vec4  o = hash43( i + g )*vec4(noiseRandomness,noiseRandomness,1.0, 1.0);
	        	vec3  d = g - f + o.xyz;
	        	float w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );
	        	a += vec2(o.w*w,w);
            }
        }
    }
    return a.x/a.y;
}

float fbm( vec2 _uv )
{
    vec3 p0 = vec3(_uv, noiseSeed);
    float 
        a = 0.5f,
        f = 1.0f,
        aSum = 0.0f,
        res = 0.0f;
    
    for ( int i=0; i<noiseOctaves; i++ ){
        float n = voronoise(p0.xy);
        n = n*n*(3.0-2.0*n);
        res += n * a;
        
        aSum += a;
        a *= noisePersistence;
        f *= 2.0;
        p0 *= mat3(cos(noiseRotation), -sin(noiseRotation), 0.0f,
                   sin(noiseRotation),  cos(noiseRotation), 0.0f,
                                 0.0f,                0.0f, 1.0f);
        p0 *= noiseFrequency;
    }
    return remap(max(res/aSum, waterLevel), 0.0f, 1.0f, 0.0f, 1.0f);
}

//         .     . GLSL .     .      

vec3 shadow( vec2 uv )
{
    uv.x *= DIM.x/DIM.y;
    vec2 uvTrans = transformPoint(uv - 0.5, clamp(-MOUSE.z, 1.0f, 200.0f), viewRotation, DRAG); // UV TRANSFORM

    float baseHeight = fbm(uvTrans);
    float normalizedHeight = remap(baseHeight, waterLevel, 1.0f, 0.0f, 1.0f);
    mat3 lightRotation = mat3(cos(lightRotation * (PI*0.25f)), -sin(lightRotation * (PI*0.25f)), 0.0f,
                              sin(lightRotation * (PI*0.25f)),  cos(lightRotation * (PI*0.25f)), 0.0f,    
                                            0.0f,                0.0f, 1.0f);

    vec3 lightDir = normalize(vec3(lightLongitude, 0.0f, lightAltitude) * lightRotation);
    vec3 p0 = vec3(uvTrans, baseHeight);
    vec3 p = p0;

    float n = 0.0f;
    for ( int i = 0; i <= lightSteps; i ++ )
    {
        n += 1;
        float h = fbm(p.xy);
        if (p.z > 1.1f) break;
        if (h > p.z) break;

        p+= lightDir * (1/lightSteps);//max(0.01, (p.z-h) * 0.01f);
    }

    float shadowMask = clamp(length(p - p0), 0.0f, 1.0f);
    float seaMask = (baseHeight > waterLevel) ? 0.0f : 1.0f;

    vec3 seaCol = (seaMask > 0.5f) ? SEA : vec3(1.0f);
    vec3 cityCol = (seaMask < 0.5f) ? vec3(hash11(normalizedHeight)+0.5f) : vec3(1.0f);

    // return vec3(hash11(normalizedHeight));
    return vec3(shadowMask*cityCol);
}

image SHADOW = glsl(shadow, ivec2(DIM));





